## 类声明
### 一个基本的类声明
1. class + 类名 + 类似对象字面量，内部是简写方法，但之间没有逗号。
2. 实例的自有属性由类的构造函数或者方法创建。
### 为何使用类语法
1. 类声明不会像函数声明被提升，而是像let一样产生TDZ。
2. 类声明以严格模式运行其中的代码，且不可切换为非严格模式。
3. 所有方法都是不可枚举的。
4. 所有方法没有内部方法[[Construct]]，即不可用new关键字调用。
5. 必须用new调用类的构造函数，否则报错。
6. 在类方法内重写类名会报错。
7. <font color=red>动手实现。</font>
## 类表达式
### 一个基本的类表达式
1. 和函数表达式一样，类表达式也不会被提升。
### 具名类表达式
1. 具名类表达式的类名只能被类内部代码引用。
## 作为一级公民的类
1. 一级公民是指能作为参数传给函数、能作为函数的返回值、能用来给变量赋值。
## 访问器属性
## 计算成员名
1. 和对象字面量的计算属性名的语法一样，类的方法和访问器属性都可以使用计算成员名。
## 生成器方法
1. 如果类实现了Symbol.iterator方法，则类的实例都是iterable。
## 静态成员
1. 方法名添加static前缀。
## 使用派生类继承
1. 关键字super既是对象，在普通方法中指向了基类的原型，在静态方法中指向了基类；又是方法，指代基类的构造函数。
2. 若派生类定义了构造函数，除非返回一个对象，否则必须调用super()方法，若没有定义构造函数，则在创建实例时，super方法会被自动调用，并使用传递的参数。
3. 只能在派生类中使用super()方法，否则报错。
4. 构造函数中super()方法应该总在访问this之前，因为super()方法负责初始化this，在此之前访问this都会报错。
### 屏蔽类方法
1. 在派生类中定义方法可以屏蔽/重写基类的同名方法。
### 继承静态成员
1. 类和函数一样，其__proto__也指向Function.prototype/Function.__proto__，但是派生类不同，其__proto__指向了基类。
### 从表达式派生类
1. 表达式的值必须是一个有[[Construct]]和原型的函数。
2. 用extends关键字继承null或生成器会报错。
### 继承内建类
1. 和传统继承不同，使用extends关键字继承的派生类的this关键字由基类创建，再被派生类装饰，所以派生类的this具有基类的所有功能。
### Symbol.species属性
1. Symbol.species是一个静态访问器属性，且不可写，即只有getter，没有setter。默认返回this，因为是静态的（作为构造函数的属性），所以等同于返回一个构造函数。
2. 若类方法中需要使用this.constructor时，最好给类定义Symbol.species属性，并改写为this.constructor[Symbol.species]，这样类的派生类可以通过定义自己的Symbol.species属性，轻易重写方法使用的构造函数。
## 在类构造函数中使用new.target