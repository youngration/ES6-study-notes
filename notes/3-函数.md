## 默认参数的函数
### ES6的默认参数
1. 调用函数时，形参未被传入实参或实参为undefined，才会使用默认参数。
### 默认参数如何影响arguments对象
1. ES6凡是使用了默认参数的函数，和ES5严格模式下的函数一样，形参和arguments对象不再双向绑定。
### 默认参数表达式
1. 默认参数的默认值时一个表达式，只有当形参使用默认参数时，该表达式才会被求值。
### 默认参数的暂存死区
1. 当函数至少有一个形参使用默认参数时，会创建一个独立的作用域——参数作用域来存储参数，并且不与函数的作用域共享。参数按照由左到右的顺序进行初始化，因为暂存死区，参数在初始化之前使用会报错，所以左边的参数不能由右边的参数初始化。
## 使用不具名参数
### 剩余参数
1. 剩余参数不会影响函数的length属性。
2. 函数只能有一个剩余参数，并且总数位于形参列表最后。
3. 对象字面量的setter访问器不能使用剩余参数，因为setter被限定只能有一个参数，而剩余参数意味着无数量限制的参数。
4. 当函数只有剩余参数时，剩余参数与arguments对象的使用几乎一致。
## Function构造函数增强的能力
1. 即默认参数与剩余参数也可以在函数的构造函数中使用。
## 展开运算符
## ES6的name属性
### 选择适当的名字
1. 所有函数都有name属性和适当的值。包括箭头函数。
### name属性的特殊情况
1. 具名函数表达式的name属性值为函数名，优先级高于被赋值的变量的名。
2. 访问器属性的getter、setter的name属性值为'get'、'set'前缀后跟访问器属性名。
3. Object.bind()创建的函数的name属性值为'bound'前缀后跟函数名。
4. Function构造函数创建的函数的name属性值为'anonymous'。
## 明确函数的双重用途
1. 函数有两个内部方法：[[Call]]和[[Construct]]。普通调用函数时，[[Call]]方法被执行；使用new调用函数时，[[Construct]]方法被执行。
### new.target元属性
1. 元属性是指非对象的属性。
2. [[Construct]]方法执行时，new.target被赋值new的目标；而[[Call]]方法执行时，new.target的值为undefined。
3. new.tartget只能在函数内部使用。
## 块级函数
1. ES6非严格模式下，块级声明函数会被提升到所在函数的顶部；而严格模式下。块级声明函数会被提升到所在块的顶部。
## 箭头函数
1. 没有this、super、arguments、new.target绑定，这些值由箭头函数创建时所在的最近的非箭头函数提供。
2. 不能使用new调用箭头函数，因为没有[[Construct]]方法。
3. 没有prototype属性。
4. 不能更改this，箭头函数的整个生命周期其this都保持不变。
5. 没有arguments对象，所以箭头函数依赖具名参数或者剩余参数。
6. 无论是否在严格模式下，箭头函数都不允许重复的具名参数，而普通函数在非严格模式下具名参数允许重复。
## 尾调优化
1. 尾调是指函数调用语句另一个函数最后的语句。
1. ES6的尾调优化必须满足：
* 函数必须处于严格模式；
* 尾调不能引用当前栈的变量，即不是闭包；
* 不能对尾调的返回值做额外操作；