### 术语
* trap：套路
* reflect：反射
* proxy：代理
### 代理和反射是什么
1. 套路：用来拦截、修改对象的一些内建行为。每个行为都由对应的套路来拦截，如给对象添加属性，会被set套路拦截。
2. 反射：套路拦截内建行为后，由反射来提供默认的行为。每个套路都有对应的反射，并且**名称和参数相同**，如set套路的反射Reflect.set()。
3. 代理：用来将对象隐匿在身后。对代理的操作也会反映在对象上，就像直接操作对象一样。通常代理使用各种套路来拦截这些操作以加入一些逻辑，再用对应的反射将相应的行为作用到对象上。
### 创建简单代理
1. Proxy()构造函数接受2个参数：target（目标对象）、object（具有各种套路的对象）。
### 用set套路验证属性
1. 拦截：给对象添加属性。
2. 参数：trapTarget（被套路的对象）、key、value、receiver（代理）；反射：Reflect.set()。
### 用get套路验证对象（object shape）
1. 拦截：从对象读取属性。
2. 参数：trapTarget（被套路的对象）、key、receiver（代理）；反射：Reflect.get()。
### 用has套路隐藏属性
1. 拦截：in操作符。
2. 参数：trapTarget（被套路的对象）、key；反射：Reflect.has()。
3. 用in操作符来判断某个属性是否存在在对象上时，它会在原型链上搜索该属性。
### 用deleteProperty套路防止属性的删除
1. 拦截：delete操作符。
2. 参数：trapTarget（被套路的对象）、key；反射：Reflect.deleteProperty()。
### 原型代理的套路
* setPrototypeOf套路
1. 拦截：Object.setPrototypeOf()。
2. 参数：trapTarget（被套路的对象）、proto（作为原型的对象）；反射：Reflect.setPrototypeOf()。
* getPrototypeOf套路
1. 拦截：Object.getPrototypeOf()。
2. 参数：trapTarget（被套路的对象）；反射：Reflect.getPrototypeOf()。
#### 原型代理的套路如何工作
1. setPrototypeOf套路在操作失败时必须返回false，否则Object.setPrototypeOf()会认为操作成功。
2. getPrototypeOf套路必须返回一个对象或者null，否则Object.getPrototypeOf()将会报错。
#### 为何有两套方法集
1. Object系和Reflect系都会调用内部方法[[SetPrototypeOf]]、[[GetPrototypeOf]]，但Reflect系更底层一些，Object系在调用前会执行几步自己的逻辑，调用后会根据返回值来决定接下来的行为。
2. 操作成功时（[[SetPrototypeOf]]返回true），Object.setPrototypeOf()返回第一个参数，而Reflect.setPrototypeOf()返回true；失败时，Object.setPrototypeOf()报错，而Reflect.setPrototypeOf()返回false。
3. Object.getPrototypeOf()允许非对象参数，并将其转化为对象，而Reflect.getPrototypeOf()报错。
4. 在代理上使用这些方法，都会被代理的setPrototypeOf、getPrototypeOf套路拦截。
### 对象扩展能力的套路
* preventExtensions套路
1. 拦截：Object.preventExtensions()。
2. 参数：trapTarget（被套路的对象）；反射：Reflect.preventExtensions()。
3. 必须返回一个布尔值来指示对象是否能扩展。
* isExtensible套路
1. 拦截：Object.isExtensible()。
2. 参数：trapTarget（被套路的对象）；反射：Reflect.isExtensible()。
3. 必须返回一个布尔值来指示操作是否成功。
#### 重复的扩展能力方法
1. Object.preventExtensions()允许非对象参数，并返回该参数，而Reflect.preventExtensions()报错。
2. Object.isExtensible()允许非对象参数，并返回false，而Reflect.isExtensible()报错。
### 属性描述器的套路
* defineProperty套路
1. 拦截：Object.defineProperty()。
2. 参数：trapTarget（被套路的对象）、key、descriptor（描述器对象）；反射：Reflect.defineProperty()。
3. 返回一个布尔值。
* getOwnPropertyDescriptor套路
1. 拦截：Object.getOwnPropertyDescriptor()。
2. 参数：trapTarget（被套路的对象）、key；反射：Reflect.getOwnPropertyDescriptor()。
3. 返回一个布尔值。
#### 阻止Object.defineProperty()
1. defineProperty返回false时，Object.defineProperty()报错。可以利用这一点，使Object.defineProperty()静默失败，即返回true，但不调用反射。
#### 描述器对象的限制
1. 调用Object.defineProperty()被套路拦截时，其描述器参数不会直接传递给defineProperty套路的descriptor，而是新建一个对象，并将描述器参数的“合法”属性（enumerable、configurable、value、writable、get、set）赋给这个对象，再传递给descriptor。
2. getOwnPropertyDescriptor返回null、undefined或者一个对象。当返回对象时，对象的属性必须是“合法”的，否则报错。
#### 重复的描述器方法
1. Object.defineProperty()返回第一个参数，而Reflect.defineProperty()返回一个布尔值。
2. 第一个参数非对象时，Object.getOwnPropertyDescriptor()会将其转化为对象，而Reflect.getOwnPropertyDescriptor()报错。
### ownKeys套路
1. 拦截：内部方法[[OwnPropertyKeys]]，外部方法Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Object.assign()。
2. 参数：trapTarget（被套路的对象）；反射：Reflect.ownKeys()。
3. 返回一个数组、类数组对象，或者错误。
4. for-in循环也会被拦截。
### 使用apply和construct套路的函数代理
* apply套路
1. 拦截：[[Call]]。
2. 参数：trapTarget（被套路的对象）、this、argumentsList（参数数组）；反射：Reflect.apply()。
* construct套路
1. 拦截：[[Construct]]。
2. 参数：trapTarget（被套路的对象）、argumentsList（参数数组）、newTarget（可选，new.target的值）；反射：Reflect.construct()。
函数的原型和其代理的原型相同。
#### 验证函数参数
1. 动手。
#### 不用new调用构造函数
1. 在apply套路中调用Reflect.construct()来实现。
2. 动手。
#### 重写抽象基类的构造函数
1. 给Reflect.construct()传第三个参数改变new.target的值。
2. 动手。
#### 可普通调用的类构造函数
1. 动手。
### 可撤销的代理
使用Proxy.revocable()方法创建可撤销的代理，参数和Proxy()构造函数的参数一致，返回一个包含两个属性的对象，其一是可撤销的代理，其二是用来撤销该代理的函数。该函数执行后，代理便不能再执行操作。
### 解决数组问题
1. 动手。
### 作为原型的代理
代理作为原型时，要使套路生效，对原型的实例的操作必须能够影响到原型。
#### 在原型上使用get套路
1. 此时第三个参数receiver指代原型的实例。
#### 在原型上使用set套路
1. 给对象设置属性时，内部方法[[Set]]先检查对象是否有该属性，如有则直接赋值，若没有则检查对象的原型，但不管原型上是否有该属性，都会给对象添加该属性并赋值。
2. 此时第四个参数receiver指代原型的实例。
#### 在原型上使用has套路
#### 作为类的原型的代理
1. 类的原型是不可写的。
2. 类的实例和作为原型的代理之间还有一层原型。