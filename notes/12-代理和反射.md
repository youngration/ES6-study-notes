### 术语
* trap：套路
* reflect：反射
* proxy：代理
### 代理和反射是什么
1. 套路：用来拦截、修改对象的一些内建行为。每个行为都由对应的套路来拦截，如给对象添加属性，会被set套路拦截。
2. 反射：套路拦截内建行为后，由反射来提供默认的行为。每个套路都有对应的反射，并且**名称和参数相同**，如set套路的反射Reflect.set()。
3. 代理：用来将对象隐匿在身后。对代理的操作也会反映在对象上，就像直接操作对象一样。通常代理使用各种套路来拦截这些操作以加入一些逻辑，再用对应的反射将相应的行为作用到对象上。
### 创建简单代理
1. Proxy构造器接受2个参数：target（目标对象）、object（具有各种套路的对象）。
### 用set套路验证属性
1. 拦截：给对象添加属性。
2. 参数：trapTarget（被套路的对象）、key、value、receiver（代理）；反射：Reflect.set()。
### 用get套路验证对象（object shape）
1. 拦截：从对象读取属性。
2. 参数：trapTarget（被套路的对象）、key、receiver（代理）；反射：Reflect.get()。
### 用has套路隐藏属性
1. 拦截：in操作符。
2. 参数：trapTarget（被套路的对象）、key；反射：Reflect.has()。
3. 用in操作符来判断某个属性是否存在在对象上时，它会在原型链上搜索该属性。
### 用deleteProperty套路防止属性的删除
1. 拦截：delete操作符。
2. 参数：trapTarget（被套路的对象）、key；反射：Reflect.deleteProperty()。
### 原型代理的套路
* setPrototypeOf套路
1. 拦截：Object.setPrototypeOf()。
2. 参数：trapTarget（被套路的对象）、proto（作为原型的对象）；反射：Reflect.setPrototypeOf()。
* getPrototypeOf套路
1. 拦截：Object.getPrototypeOf()。
2. 参数：trapTarget（被套路的对象）；反射：Reflect.getPrototypeOf()。
##### 原型代理的套路如何工作
1. setPrototypeOf套路在操作失败时必须返回false，否则Object.setPrototypeOf()会认为操作成功。
2. getPrototypeOf套路必须返回一个对象或者null，否则Object.getPrototypeOf()将会报错。
##### 为何有两套方法集
1. Object系和Reflect系都会调用内部方法[[SetPrototypeOf]]、[[GetPrototypeOf]]，但Reflect系更底层一些，Object系在调用前会执行几步自己的逻辑，调用后会根据返回值来决定接下来的行为。
2. 操作成功时（[[SetPrototypeOf]]返回true），Object.setPrototypeOf()返回第一个参数，而Reflect.setPrototypeOf()返回true；失败时，Object.setPrototypeOf()报错，而Reflect.setPrototypeOf()返回false。
3. Object.getPrototypeOf()允许非对象参数，并将其转化为对象，而Reflect.getPrototypeOf()报错。
4. 在代理上使用这些方法，都会被代理的setPrototypeOf、getPrototypeOf套路拦截。
### 对象扩展能力套路
